{
  "_from": "body-parser",
  "_id": "body-parser@1.18.3",
  "_inBundle": false,
  "_integrity": "sha1-WykhmP/dVTs6DyDe0FkrlWlVyLQ=",
  "_location": "/body-parser",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "body-parser",
    "fetchSpec": "latest",
    "name": "body-parser",
    "raw": "body-parser",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.18.3.tgz",
  "_shasum": "5b292198ffdd553b3a0f20ded0592b956955c8b4",
  "_spec": "body-parser",
  "_where": "/nfs/nas02a_personnels/uapviup/fredouil/Work/ArchiWeb/MEAN",
  "bugs": {
    "url": "https://github.com/expressjs/body-parser/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "Douglas Christopher Wilson",
      "email": "doug@somethingdoug.com"
    },
    {
      "name": "Jonathan Ong",
      "email": "me@jongleberry.com",
      "url": "http://jongleberry.com"
    }
  ],
  "dependencies": {
    "bytes": "3.0.0",
    "content-type": "~1.0.4",
    "debug": "2.6.9",
    "depd": "~1.1.2",
    "http-errors": "~1.6.3",
    "iconv-lite": "0.4.23",
    "on-finished": "~2.3.0",
    "qs": "6.5.2",
    "raw-body": "2.3.3",
    "type-is": "~1.6.16"
  },
  "deprecated": false,
  "description": "Node.js body parsing middleware",
  "devDependencies": {
    "eslint": "4.19.1",
    "eslint-config-standard": "11.0.0",
    "eslint-plugin-import": "2.11.0",
    "eslint-plugin-markdown": "1.0.0-beta.6",
    "eslint-plugin-node": "6.0.1",
    "eslint-plugin-promise": "3.7.0",
    "eslint-plugin-standard": "3.1.0",
    "istanbul": "0.4.5",
    "methods": "1.1.2",
    "mocha": "2.5.3",
    "safe-buffer": "5.1.2",
    "supertest": "1.1.0"
  },
  "engines": {
    "node": ">= 0.8"
  },
  "files": [
    "HISTORY.md",
    "LICENSE",
    "index.js",
    "lib/"
  ],
  "homepage": "https://github.com/expressjs/body-parser#readme",
  "license": "MIT",
  "name": "body-parser",
  "optionalDependencies": {},
  "readme": "# body-parser\r\n\r\n[![NPM Version][npm-image]][npm-url]\r\n[![NPM Downloads][downloads-image]][downloads-url]\r\n[![Build Status][travis-image]][travis-url]\r\n[![Test Coverage][coveralls-image]][coveralls-url]\r\n\r\nNode.js body parsing middleware.\r\n\r\nParse incoming request bodies in a middleware before your handlers, available\r\nunder the `req.body` property.\r\n\r\n**Note** As `req.body`'s shape is based on user-controlled input, all\r\nproperties and values in this object are untrusted and should be validated\r\nbefore trusting. For example, `req.body.foo.toString()` may fail in multiple\r\nways, for example the `foo` property may not be there or may not be a string,\r\nand `toString` may not be a function and instead a string or other user input.\r\n\r\n[Learn about the anatomy of an HTTP transaction in Node.js](https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/).\r\n\r\n_This does not handle multipart bodies_, due to their complex and typically\r\nlarge nature. For multipart bodies, you may be interested in the following\r\nmodules:\r\n\r\n  * [busboy](https://www.npmjs.org/package/busboy#readme) and\r\n    [connect-busboy](https://www.npmjs.org/package/connect-busboy#readme)\r\n  * [multiparty](https://www.npmjs.org/package/multiparty#readme) and\r\n    [connect-multiparty](https://www.npmjs.org/package/connect-multiparty#readme)\r\n  * [formidable](https://www.npmjs.org/package/formidable#readme)\r\n  * [multer](https://www.npmjs.org/package/multer#readme)\r\n\r\nThis module provides the following parsers:\r\n\r\n  * [JSON body parser](#bodyparserjsonoptions)\r\n  * [Raw body parser](#bodyparserrawoptions)\r\n  * [Text body parser](#bodyparsertextoptions)\r\n  * [URL-encoded form body parser](#bodyparserurlencodedoptions)\r\n\r\nOther body parsers you might be interested in:\r\n\r\n- [body](https://www.npmjs.org/package/body#readme)\r\n- [co-body](https://www.npmjs.org/package/co-body#readme)\r\n\r\n## Installation\r\n\r\n```sh\r\n$ npm install body-parser\r\n```\r\n\r\n## API\r\n\r\n<!-- eslint-disable no-unused-vars -->\r\n\r\n```js\r\nvar bodyParser = require('body-parser')\r\n```\r\n\r\nThe `bodyParser` object exposes various factories to create middlewares. All\r\nmiddlewares will populate the `req.body` property with the parsed body when\r\nthe `Content-Type` request header matches the `type` option, or an empty\r\nobject (`{}`) if there was no body to parse, the `Content-Type` was not matched,\r\nor an error occurred.\r\n\r\nThe various errors returned by this module are described in the\r\n[errors section](#errors).\r\n\r\n### bodyParser.json([options])\r\n\r\nReturns middleware that only parses `json` and only looks at requests where\r\nthe `Content-Type` header matches the `type` option. This parser accepts any\r\nUnicode encoding of the body and supports automatic inflation of `gzip` and\r\n`deflate` encodings.\r\n\r\nA new `body` object containing the parsed data is populated on the `request`\r\nobject after the middleware (i.e. `req.body`).\r\n\r\n#### Options\r\n\r\nThe `json` function takes an optional `options` object that may contain any of\r\nthe following keys:\r\n\r\n##### inflate\r\n\r\nWhen set to `true`, then deflated (compressed) bodies will be inflated; when\r\n`false`, deflated bodies are rejected. Defaults to `true`.\r\n\r\n##### limit\r\n\r\nControls the maximum request body size. If this is a number, then the value\r\nspecifies the number of bytes; if it is a string, the value is passed to the\r\n[bytes](https://www.npmjs.com/package/bytes) library for parsing. Defaults\r\nto `'100kb'`.\r\n\r\n##### reviver\r\n\r\nThe `reviver` option is passed directly to `JSON.parse` as the second\r\nargument. You can find more information on this argument\r\n[in the MDN documentation about JSON.parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter).\r\n\r\n##### strict\r\n\r\nWhen set to `true`, will only accept arrays and objects; when `false` will\r\naccept anything `JSON.parse` accepts. Defaults to `true`.\r\n\r\n##### type\r\n\r\nThe `type` option is used to determine what media type the middleware will\r\nparse. This option can be a string, array of strings, or a function. If not a\r\nfunction, `type` option is passed directly to the\r\n[type-is](https://www.npmjs.org/package/type-is#readme) library and this can\r\nbe an extension name (like `json`), a mime type (like `application/json`), or\r\na mime type with a wildcard (like `*/*` or `*/json`). If a function, the `type`\r\noption is called as `fn(req)` and the request is parsed if it returns a truthy\r\nvalue. Defaults to `application/json`.\r\n\r\n##### verify\r\n\r\nThe `verify` option, if supplied, is called as `verify(req, res, buf, encoding)`,\r\nwhere `buf` is a `Buffer` of the raw request body and `encoding` is the\r\nencoding of the request. The parsing can be aborted by throwing an error.\r\n\r\n### bodyParser.raw([options])\r\n\r\nReturns middleware that parses all bodies as a `Buffer` and only looks at\r\nrequests where the `Content-Type` header matches the `type` option. This\r\nparser supports automatic inflation of `gzip` and `deflate` encodings.\r\n\r\nA new `body` object containing the parsed data is populated on the `request`\r\nobject after the middleware (i.e. `req.body`). This will be a `Buffer` object\r\nof the body.\r\n\r\n#### Options\r\n\r\nThe `raw` function takes an optional `options` object that may contain any of\r\nthe following keys:\r\n\r\n##### inflate\r\n\r\nWhen set to `true`, then deflated (compressed) bodies will be inflated; when\r\n`false`, deflated bodies are rejected. Defaults to `true`.\r\n\r\n##### limit\r\n\r\nControls the maximum request body size. If this is a number, then the value\r\nspecifies the number of bytes; if it is a string, the value is passed to the\r\n[bytes](https://www.npmjs.com/package/bytes) library for parsing. Defaults\r\nto `'100kb'`.\r\n\r\n##### type\r\n\r\nThe `type` option is used to determine what media type the middleware will\r\nparse. This option can be a string, array of strings, or a function.\r\nIf not a function, `type` option is passed directly to the\r\n[type-is](https://www.npmjs.org/package/type-is#readme) library and this\r\ncan be an extension name (like `bin`), a mime type (like\r\n`application/octet-stream`), or a mime type with a wildcard (like `*/*` or\r\n`application/*`). If a function, the `type` option is called as `fn(req)`\r\nand the request is parsed if it returns a truthy value. Defaults to\r\n`application/octet-stream`.\r\n\r\n##### verify\r\n\r\nThe `verify` option, if supplied, is called as `verify(req, res, buf, encoding)`,\r\nwhere `buf` is a `Buffer` of the raw request body and `encoding` is the\r\nencoding of the request. The parsing can be aborted by throwing an error.\r\n\r\n### bodyParser.text([options])\r\n\r\nReturns middleware that parses all bodies as a string and only looks at\r\nrequests where the `Content-Type` header matches the `type` option. This\r\nparser supports automatic inflation of `gzip` and `deflate` encodings.\r\n\r\nA new `body` string containing the parsed data is populated on the `request`\r\nobject after the middleware (i.e. `req.body`). This will be a string of the\r\nbody.\r\n\r\n#### Options\r\n\r\nThe `text` function takes an optional `options` object that may contain any of\r\nthe following keys:\r\n\r\n##### defaultCharset\r\n\r\nSpecify the default character set for the text content if the charset is not\r\nspecified in the `Content-Type` header of the request. Defaults to `utf-8`.\r\n\r\n##### inflate\r\n\r\nWhen set to `true`, then deflated (compressed) bodies will be inflated; when\r\n`false`, deflated bodies are rejected. Defaults to `true`.\r\n\r\n##### limit\r\n\r\nControls the maximum request body size. If this is a number, then the value\r\nspecifies the number of bytes; if it is a string, the value is passed to the\r\n[bytes](https://www.npmjs.com/package/bytes) library for parsing. Defaults\r\nto `'100kb'`.\r\n\r\n##### type\r\n\r\nThe `type` option is used to determine what media type the middleware will\r\nparse. This option can be a string, array of strings, or a function. If not\r\na function, `type` option is passed directly to the\r\n[type-is](https://www.npmjs.org/package/type-is#readme) library and this can\r\nbe an extension name (like `txt`), a mime type (like `text/plain`), or a mime\r\ntype with a wildcard (like `*/*` or `text/*`). If a function, the `type`\r\noption is called as `fn(req)` and the request is parsed if it returns a\r\ntruthy value. Defaults to `text/plain`.\r\n\r\n##### verify\r\n\r\nThe `verify` option, if supplied, is called as `verify(req, res, buf, encoding)`,\r\nwhere `buf` is a `Buffer` of the raw request body and `encoding` is the\r\nencoding of the request. The parsing can be aborted by throwing an error.\r\n\r\n### bodyParser.urlencoded([options])\r\n\r\nReturns middleware that only parses `urlencoded` bodies and only looks at\r\nrequests where the `Content-Type` header matches the `type` option. This\r\nparser accepts only UTF-8 encoding of the body and supports automatic\r\ninflation of `gzip` and `deflate` encodings.\r\n\r\nA new `body` object containing the parsed data is populated on the `request`\r\nobject after the middleware (i.e. `req.body`). This object will contain\r\nkey-value pairs, where the value can be a string or array (when `extended` is\r\n`false`), or any type (when `extended` is `true`).\r\n\r\n#### Options\r\n\r\nThe `urlencoded` function takes an optional `options` object that may contain\r\nany of the following keys:\r\n\r\n##### extended\r\n\r\nThe `extended` option allows to choose between parsing the URL-encoded data\r\nwith the `querystring` library (when `false`) or the `qs` library (when\r\n`true`). The \"extended\" syntax allows for rich objects and arrays to be\r\nencoded into the URL-encoded format, allowing for a JSON-like experience\r\nwith URL-encoded. For more information, please\r\n[see the qs library](https://www.npmjs.org/package/qs#readme).\r\n\r\nDefaults to `true`, but using the default has been deprecated. Please\r\nresearch into the difference between `qs` and `querystring` and choose the\r\nappropriate setting.\r\n\r\n##### inflate\r\n\r\nWhen set to `true`, then deflated (compressed) bodies will be inflated; when\r\n`false`, deflated bodies are rejected. Defaults to `true`.\r\n\r\n##### limit\r\n\r\nControls the maximum request body size. If this is a number, then the value\r\nspecifies the number of bytes; if it is a string, the value is passed to the\r\n[bytes](https://www.npmjs.com/package/bytes) library for parsing. Defaults\r\nto `'100kb'`.\r\n\r\n##### parameterLimit\r\n\r\nThe `parameterLimit` option controls the maximum number of parameters that\r\nare allowed in the URL-encoded data. If a request contains more parameters\r\nthan this value, a 413 will be returned to the client. Defaults to `1000`.\r\n\r\n##### type\r\n\r\nThe `type` option is used to determine what media type the middleware will\r\nparse. This option can be a string, array of strings, or a function. If not\r\na function, `type` option is passed directly to the\r\n[type-is](https://www.npmjs.org/package/type-is#readme) library and this can\r\nbe an extension name (like `urlencoded`), a mime type (like\r\n`application/x-www-form-urlencoded`), or a mime type with a wildcard (like\r\n`*/x-www-form-urlencoded`). If a function, the `type` option is called as\r\n`fn(req)` and the request is parsed if it returns a truthy value. Defaults\r\nto `application/x-www-form-urlencoded`.\r\n\r\n##### verify\r\n\r\nThe `verify` option, if supplied, is called as `verify(req, res, buf, encoding)`,\r\nwhere `buf` is a `Buffer` of the raw request body and `encoding` is the\r\nencoding of the request. The parsing can be aborted by throwing an error.\r\n\r\n## Errors\r\n\r\nThe middlewares provided by this module create errors depending on the error\r\ncondition during parsing. The errors will typically have a `status`/`statusCode`\r\nproperty that contains the suggested HTTP response code, an `expose` property\r\nto determine if the `message` property should be displayed to the client, a\r\n`type` property to determine the type of error without matching against the\r\n`message`, and a `body` property containing the read body, if available.\r\n\r\nThe following are the common errors emitted, though any error can come through\r\nfor various reasons.\r\n\r\n### content encoding unsupported\r\n\r\nThis error will occur when the request had a `Content-Encoding` header that\r\ncontained an encoding but the \"inflation\" option was set to `false`. The\r\n`status` property is set to `415`, the `type` property is set to\r\n`'encoding.unsupported'`, and the `charset` property will be set to the\r\nencoding that is unsupported.\r\n\r\n### request aborted\r\n\r\nThis error will occur when the request is aborted by the client before reading\r\nthe body has finished. The `received` property will be set to the number of\r\nbytes received before the request was aborted and the `expected` property is\r\nset to the number of expected bytes. The `status` property is set to `400`\r\nand `type` property is set to `'request.aborted'`.\r\n\r\n### request entity too large\r\n\r\nThis error will occur when the request body's size is larger than the \"limit\"\r\noption. The `limit` property will be set to the byte limit and the `length`\r\nproperty will be set to the request body's length. The `status` property is\r\nset to `413` and the `type` property is set to `'entity.too.large'`.\r\n\r\n### request size did not match content length\r\n\r\nThis error will occur when the request's length did not match the length from\r\nthe `Content-Length` header. This typically occurs when the request is malformed,\r\ntypically when the `Content-Length` header was calculated based on characters\r\ninstead of bytes. The `status` property is set to `400` and the `type` property\r\nis set to `'request.size.invalid'`.\r\n\r\n### stream encoding should not be set\r\n\r\nThis error will occur when something called the `req.setEncoding` method prior\r\nto this middleware. This module operates directly on bytes only and you cannot\r\ncall `req.setEncoding` when using this module. The `status` property is set to\r\n`500` and the `type` property is set to `'stream.encoding.set'`.\r\n\r\n### too many parameters\r\n\r\nThis error will occur when the content of the request exceeds the configured\r\n`parameterLimit` for the `urlencoded` parser. The `status` property is set to\r\n`413` and the `type` property is set to `'parameters.too.many'`.\r\n\r\n### unsupported charset \"BOGUS\"\r\n\r\nThis error will occur when the request had a charset parameter in the\r\n`Content-Type` header, but the `iconv-lite` module does not support it OR the\r\nparser does not support it. The charset is contained in the message as well\r\nas in the `charset` property. The `status` property is set to `415`, the\r\n`type` property is set to `'charset.unsupported'`, and the `charset` property\r\nis set to the charset that is unsupported.\r\n\r\n### unsupported content encoding \"bogus\"\r\n\r\nThis error will occur when the request had a `Content-Encoding` header that\r\ncontained an unsupported encoding. The encoding is contained in the message\r\nas well as in the `encoding` property. The `status` property is set to `415`,\r\nthe `type` property is set to `'encoding.unsupported'`, and the `encoding`\r\nproperty is set to the encoding that is unsupported.\r\n\r\n## Examples\r\n\r\n### Express/Connect top-level generic\r\n\r\nThis example demonstrates adding a generic JSON and URL-encoded parser as a\r\ntop-level middleware, which will parse the bodies of all incoming requests.\r\nThis is the simplest setup.\r\n\r\n```js\r\nvar express = require('express')\r\nvar bodyParser = require('body-parser')\r\n\r\nvar app = express()\r\n\r\n// parse application/x-www-form-urlencoded\r\napp.use(bodyParser.urlencoded({ extended: false }))\r\n\r\n// parse application/json\r\napp.use(bodyParser.json())\r\n\r\napp.use(function (req, res) {\r\n  res.setHeader('Content-Type', 'text/plain')\r\n  res.write('you posted:\\n')\r\n  res.end(JSON.stringify(req.body, null, 2))\r\n})\r\n```\r\n\r\n### Express route-specific\r\n\r\nThis example demonstrates adding body parsers specifically to the routes that\r\nneed them. In general, this is the most recommended way to use body-parser with\r\nExpress.\r\n\r\n```js\r\nvar express = require('express')\r\nvar bodyParser = require('body-parser')\r\n\r\nvar app = express()\r\n\r\n// create application/json parser\r\nvar jsonParser = bodyParser.json()\r\n\r\n// create application/x-www-form-urlencoded parser\r\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\r\n\r\n// POST /login gets urlencoded bodies\r\napp.post('/login', urlencodedParser, function (req, res) {\r\n  if (!req.body) return res.sendStatus(400)\r\n  res.send('welcome, ' + req.body.username)\r\n})\r\n\r\n// POST /api/users gets JSON bodies\r\napp.post('/api/users', jsonParser, function (req, res) {\r\n  if (!req.body) return res.sendStatus(400)\r\n  // create user in req.body\r\n})\r\n```\r\n\r\n### Change accepted type for parsers\r\n\r\nAll the parsers accept a `type` option which allows you to change the\r\n`Content-Type` that the middleware will parse.\r\n\r\n```js\r\nvar express = require('express')\r\nvar bodyParser = require('body-parser')\r\n\r\nvar app = express()\r\n\r\n// parse various different custom JSON types as JSON\r\napp.use(bodyParser.json({ type: 'application/*+json' }))\r\n\r\n// parse some custom thing into a Buffer\r\napp.use(bodyParser.raw({ type: 'application/vnd.custom-type' }))\r\n\r\n// parse an HTML body into a string\r\napp.use(bodyParser.text({ type: 'text/html' }))\r\n```\r\n\r\n## License\r\n\r\n[MIT](LICENSE)\r\n\r\n[npm-image]: https://img.shields.io/npm/v/body-parser.svg\r\n[npm-url]: https://npmjs.org/package/body-parser\r\n[travis-image]: https://img.shields.io/travis/expressjs/body-parser/master.svg\r\n[travis-url]: https://travis-ci.org/expressjs/body-parser\r\n[coveralls-image]: https://img.shields.io/coveralls/expressjs/body-parser/master.svg\r\n[coveralls-url]: https://coveralls.io/r/expressjs/body-parser?branch=master\r\n[downloads-image]: https://img.shields.io/npm/dm/body-parser.svg\r\n[downloads-url]: https://npmjs.org/package/body-parser\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/expressjs/body-parser.git"
  },
  "scripts": {
    "lint": "eslint --plugin markdown --ext js,md .",
    "test": "mocha --require test/support/env --reporter spec --check-leaks --bail test/",
    "test-cov": "istanbul cover node_modules/mocha/bin/_mocha -- --require test/support/env --reporter dot --check-leaks test/",
    "test-travis": "istanbul cover node_modules/mocha/bin/_mocha --report lcovonly -- --require test/support/env --reporter spec --check-leaks test/"
  },
  "version": "1.18.3"
}
